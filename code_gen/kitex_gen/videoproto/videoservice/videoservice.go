// Code generated by Kitex v0.4.4. DO NOT EDIT.

package videoservice

import (
	"context"
	"douyin/code_gen/kitex_gen/videoproto"
	"fmt"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	proto "google.golang.org/protobuf/proto"
)

func serviceInfo() *kitex.ServiceInfo {
	return videoServiceServiceInfo
}

var videoServiceServiceInfo = NewServiceInfo()

func NewServiceInfo() *kitex.ServiceInfo {
	serviceName := "VideoService"
	handlerType := (*videoproto.VideoService)(nil)
	methods := map[string]kitex.MethodInfo{
		"CreateVideo":          kitex.NewMethodInfo(createVideoHandler, newCreateVideoArgs, newCreateVideoResult, false),
		"GetVideoListByUserId": kitex.NewMethodInfo(getVideoListByUserIdHandler, newGetVideoListByUserIdArgs, newGetVideoListByUserIdResult, false),
		"GetVideoListByTime":   kitex.NewMethodInfo(getVideoListByTimeHandler, newGetVideoListByTimeArgs, newGetVideoListByTimeResult, false),
		"LikeVideo":            kitex.NewMethodInfo(likeVideoHandler, newLikeVideoArgs, newLikeVideoResult, false),
		"UnLikeVideo":          kitex.NewMethodInfo(unLikeVideoHandler, newUnLikeVideoArgs, newUnLikeVideoResult, false),
		"GetLikeVideoList":     kitex.NewMethodInfo(getLikeVideoListHandler, newGetLikeVideoListArgs, newGetLikeVideoListResult, false),
	}
	extra := map[string]interface{}{
		"PackageName": "video",
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.4.4",
		Extra:           extra,
	}
	return svcInfo
}

func createVideoHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(videoproto.CreateVideoReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(videoproto.VideoService).CreateVideo(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CreateVideoArgs:
		success, err := handler.(videoproto.VideoService).CreateVideo(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreateVideoResult)
		realResult.Success = success
	}
	return nil
}
func newCreateVideoArgs() interface{} {
	return &CreateVideoArgs{}
}

func newCreateVideoResult() interface{} {
	return &CreateVideoResult{}
}

type CreateVideoArgs struct {
	Req *videoproto.CreateVideoReq
}

func (p *CreateVideoArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(videoproto.CreateVideoReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *CreateVideoArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *CreateVideoArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *CreateVideoArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CreateVideoArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CreateVideoArgs) Unmarshal(in []byte) error {
	msg := new(videoproto.CreateVideoReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreateVideoArgs_Req_DEFAULT *videoproto.CreateVideoReq

func (p *CreateVideoArgs) GetReq() *videoproto.CreateVideoReq {
	if !p.IsSetReq() {
		return CreateVideoArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreateVideoArgs) IsSetReq() bool {
	return p.Req != nil
}

type CreateVideoResult struct {
	Success *videoproto.CreateVideoResp
}

var CreateVideoResult_Success_DEFAULT *videoproto.CreateVideoResp

func (p *CreateVideoResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(videoproto.CreateVideoResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *CreateVideoResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *CreateVideoResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *CreateVideoResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CreateVideoResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CreateVideoResult) Unmarshal(in []byte) error {
	msg := new(videoproto.CreateVideoResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreateVideoResult) GetSuccess() *videoproto.CreateVideoResp {
	if !p.IsSetSuccess() {
		return CreateVideoResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreateVideoResult) SetSuccess(x interface{}) {
	p.Success = x.(*videoproto.CreateVideoResp)
}

func (p *CreateVideoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func getVideoListByUserIdHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(videoproto.GetVideoListByUserIdReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(videoproto.VideoService).GetVideoListByUserId(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetVideoListByUserIdArgs:
		success, err := handler.(videoproto.VideoService).GetVideoListByUserId(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetVideoListByUserIdResult)
		realResult.Success = success
	}
	return nil
}
func newGetVideoListByUserIdArgs() interface{} {
	return &GetVideoListByUserIdArgs{}
}

func newGetVideoListByUserIdResult() interface{} {
	return &GetVideoListByUserIdResult{}
}

type GetVideoListByUserIdArgs struct {
	Req *videoproto.GetVideoListByUserIdReq
}

func (p *GetVideoListByUserIdArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(videoproto.GetVideoListByUserIdReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetVideoListByUserIdArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetVideoListByUserIdArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetVideoListByUserIdArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in GetVideoListByUserIdArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *GetVideoListByUserIdArgs) Unmarshal(in []byte) error {
	msg := new(videoproto.GetVideoListByUserIdReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetVideoListByUserIdArgs_Req_DEFAULT *videoproto.GetVideoListByUserIdReq

func (p *GetVideoListByUserIdArgs) GetReq() *videoproto.GetVideoListByUserIdReq {
	if !p.IsSetReq() {
		return GetVideoListByUserIdArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetVideoListByUserIdArgs) IsSetReq() bool {
	return p.Req != nil
}

type GetVideoListByUserIdResult struct {
	Success *videoproto.GetVideoListByUserIdResp
}

var GetVideoListByUserIdResult_Success_DEFAULT *videoproto.GetVideoListByUserIdResp

func (p *GetVideoListByUserIdResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(videoproto.GetVideoListByUserIdResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetVideoListByUserIdResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetVideoListByUserIdResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetVideoListByUserIdResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in GetVideoListByUserIdResult")
	}
	return proto.Marshal(p.Success)
}

func (p *GetVideoListByUserIdResult) Unmarshal(in []byte) error {
	msg := new(videoproto.GetVideoListByUserIdResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetVideoListByUserIdResult) GetSuccess() *videoproto.GetVideoListByUserIdResp {
	if !p.IsSetSuccess() {
		return GetVideoListByUserIdResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetVideoListByUserIdResult) SetSuccess(x interface{}) {
	p.Success = x.(*videoproto.GetVideoListByUserIdResp)
}

func (p *GetVideoListByUserIdResult) IsSetSuccess() bool {
	return p.Success != nil
}

func getVideoListByTimeHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(videoproto.GetVideoListByTimeReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(videoproto.VideoService).GetVideoListByTime(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetVideoListByTimeArgs:
		success, err := handler.(videoproto.VideoService).GetVideoListByTime(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetVideoListByTimeResult)
		realResult.Success = success
	}
	return nil
}
func newGetVideoListByTimeArgs() interface{} {
	return &GetVideoListByTimeArgs{}
}

func newGetVideoListByTimeResult() interface{} {
	return &GetVideoListByTimeResult{}
}

type GetVideoListByTimeArgs struct {
	Req *videoproto.GetVideoListByTimeReq
}

func (p *GetVideoListByTimeArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(videoproto.GetVideoListByTimeReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetVideoListByTimeArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetVideoListByTimeArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetVideoListByTimeArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in GetVideoListByTimeArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *GetVideoListByTimeArgs) Unmarshal(in []byte) error {
	msg := new(videoproto.GetVideoListByTimeReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetVideoListByTimeArgs_Req_DEFAULT *videoproto.GetVideoListByTimeReq

func (p *GetVideoListByTimeArgs) GetReq() *videoproto.GetVideoListByTimeReq {
	if !p.IsSetReq() {
		return GetVideoListByTimeArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetVideoListByTimeArgs) IsSetReq() bool {
	return p.Req != nil
}

type GetVideoListByTimeResult struct {
	Success *videoproto.GetVideoListByTimeResp
}

var GetVideoListByTimeResult_Success_DEFAULT *videoproto.GetVideoListByTimeResp

func (p *GetVideoListByTimeResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(videoproto.GetVideoListByTimeResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetVideoListByTimeResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetVideoListByTimeResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetVideoListByTimeResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in GetVideoListByTimeResult")
	}
	return proto.Marshal(p.Success)
}

func (p *GetVideoListByTimeResult) Unmarshal(in []byte) error {
	msg := new(videoproto.GetVideoListByTimeResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetVideoListByTimeResult) GetSuccess() *videoproto.GetVideoListByTimeResp {
	if !p.IsSetSuccess() {
		return GetVideoListByTimeResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetVideoListByTimeResult) SetSuccess(x interface{}) {
	p.Success = x.(*videoproto.GetVideoListByTimeResp)
}

func (p *GetVideoListByTimeResult) IsSetSuccess() bool {
	return p.Success != nil
}

func likeVideoHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(videoproto.LikeVideoReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(videoproto.VideoService).LikeVideo(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *LikeVideoArgs:
		success, err := handler.(videoproto.VideoService).LikeVideo(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*LikeVideoResult)
		realResult.Success = success
	}
	return nil
}
func newLikeVideoArgs() interface{} {
	return &LikeVideoArgs{}
}

func newLikeVideoResult() interface{} {
	return &LikeVideoResult{}
}

type LikeVideoArgs struct {
	Req *videoproto.LikeVideoReq
}

func (p *LikeVideoArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(videoproto.LikeVideoReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *LikeVideoArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *LikeVideoArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *LikeVideoArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in LikeVideoArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *LikeVideoArgs) Unmarshal(in []byte) error {
	msg := new(videoproto.LikeVideoReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var LikeVideoArgs_Req_DEFAULT *videoproto.LikeVideoReq

func (p *LikeVideoArgs) GetReq() *videoproto.LikeVideoReq {
	if !p.IsSetReq() {
		return LikeVideoArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *LikeVideoArgs) IsSetReq() bool {
	return p.Req != nil
}

type LikeVideoResult struct {
	Success *videoproto.LikeVideoResp
}

var LikeVideoResult_Success_DEFAULT *videoproto.LikeVideoResp

func (p *LikeVideoResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(videoproto.LikeVideoResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *LikeVideoResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *LikeVideoResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *LikeVideoResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in LikeVideoResult")
	}
	return proto.Marshal(p.Success)
}

func (p *LikeVideoResult) Unmarshal(in []byte) error {
	msg := new(videoproto.LikeVideoResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *LikeVideoResult) GetSuccess() *videoproto.LikeVideoResp {
	if !p.IsSetSuccess() {
		return LikeVideoResult_Success_DEFAULT
	}
	return p.Success
}

func (p *LikeVideoResult) SetSuccess(x interface{}) {
	p.Success = x.(*videoproto.LikeVideoResp)
}

func (p *LikeVideoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func unLikeVideoHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(videoproto.UnLikeVideoReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(videoproto.VideoService).UnLikeVideo(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *UnLikeVideoArgs:
		success, err := handler.(videoproto.VideoService).UnLikeVideo(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UnLikeVideoResult)
		realResult.Success = success
	}
	return nil
}
func newUnLikeVideoArgs() interface{} {
	return &UnLikeVideoArgs{}
}

func newUnLikeVideoResult() interface{} {
	return &UnLikeVideoResult{}
}

type UnLikeVideoArgs struct {
	Req *videoproto.UnLikeVideoReq
}

func (p *UnLikeVideoArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(videoproto.UnLikeVideoReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *UnLikeVideoArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *UnLikeVideoArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *UnLikeVideoArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in UnLikeVideoArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *UnLikeVideoArgs) Unmarshal(in []byte) error {
	msg := new(videoproto.UnLikeVideoReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UnLikeVideoArgs_Req_DEFAULT *videoproto.UnLikeVideoReq

func (p *UnLikeVideoArgs) GetReq() *videoproto.UnLikeVideoReq {
	if !p.IsSetReq() {
		return UnLikeVideoArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UnLikeVideoArgs) IsSetReq() bool {
	return p.Req != nil
}

type UnLikeVideoResult struct {
	Success *videoproto.UnLikeVideoResp
}

var UnLikeVideoResult_Success_DEFAULT *videoproto.UnLikeVideoResp

func (p *UnLikeVideoResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(videoproto.UnLikeVideoResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *UnLikeVideoResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *UnLikeVideoResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *UnLikeVideoResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in UnLikeVideoResult")
	}
	return proto.Marshal(p.Success)
}

func (p *UnLikeVideoResult) Unmarshal(in []byte) error {
	msg := new(videoproto.UnLikeVideoResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UnLikeVideoResult) GetSuccess() *videoproto.UnLikeVideoResp {
	if !p.IsSetSuccess() {
		return UnLikeVideoResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UnLikeVideoResult) SetSuccess(x interface{}) {
	p.Success = x.(*videoproto.UnLikeVideoResp)
}

func (p *UnLikeVideoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func getLikeVideoListHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(videoproto.GetLikeVideoListReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(videoproto.VideoService).GetLikeVideoList(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetLikeVideoListArgs:
		success, err := handler.(videoproto.VideoService).GetLikeVideoList(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetLikeVideoListResult)
		realResult.Success = success
	}
	return nil
}
func newGetLikeVideoListArgs() interface{} {
	return &GetLikeVideoListArgs{}
}

func newGetLikeVideoListResult() interface{} {
	return &GetLikeVideoListResult{}
}

type GetLikeVideoListArgs struct {
	Req *videoproto.GetLikeVideoListReq
}

func (p *GetLikeVideoListArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(videoproto.GetLikeVideoListReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetLikeVideoListArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetLikeVideoListArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetLikeVideoListArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in GetLikeVideoListArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *GetLikeVideoListArgs) Unmarshal(in []byte) error {
	msg := new(videoproto.GetLikeVideoListReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetLikeVideoListArgs_Req_DEFAULT *videoproto.GetLikeVideoListReq

func (p *GetLikeVideoListArgs) GetReq() *videoproto.GetLikeVideoListReq {
	if !p.IsSetReq() {
		return GetLikeVideoListArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetLikeVideoListArgs) IsSetReq() bool {
	return p.Req != nil
}

type GetLikeVideoListResult struct {
	Success *videoproto.GetLikeVideoListResp
}

var GetLikeVideoListResult_Success_DEFAULT *videoproto.GetLikeVideoListResp

func (p *GetLikeVideoListResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(videoproto.GetLikeVideoListResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetLikeVideoListResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetLikeVideoListResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetLikeVideoListResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in GetLikeVideoListResult")
	}
	return proto.Marshal(p.Success)
}

func (p *GetLikeVideoListResult) Unmarshal(in []byte) error {
	msg := new(videoproto.GetLikeVideoListResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetLikeVideoListResult) GetSuccess() *videoproto.GetLikeVideoListResp {
	if !p.IsSetSuccess() {
		return GetLikeVideoListResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetLikeVideoListResult) SetSuccess(x interface{}) {
	p.Success = x.(*videoproto.GetLikeVideoListResp)
}

func (p *GetLikeVideoListResult) IsSetSuccess() bool {
	return p.Success != nil
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) CreateVideo(ctx context.Context, Req *videoproto.CreateVideoReq) (r *videoproto.CreateVideoResp, err error) {
	var _args CreateVideoArgs
	_args.Req = Req
	var _result CreateVideoResult
	if err = p.c.Call(ctx, "CreateVideo", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetVideoListByUserId(ctx context.Context, Req *videoproto.GetVideoListByUserIdReq) (r *videoproto.GetVideoListByUserIdResp, err error) {
	var _args GetVideoListByUserIdArgs
	_args.Req = Req
	var _result GetVideoListByUserIdResult
	if err = p.c.Call(ctx, "GetVideoListByUserId", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetVideoListByTime(ctx context.Context, Req *videoproto.GetVideoListByTimeReq) (r *videoproto.GetVideoListByTimeResp, err error) {
	var _args GetVideoListByTimeArgs
	_args.Req = Req
	var _result GetVideoListByTimeResult
	if err = p.c.Call(ctx, "GetVideoListByTime", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) LikeVideo(ctx context.Context, Req *videoproto.LikeVideoReq) (r *videoproto.LikeVideoResp, err error) {
	var _args LikeVideoArgs
	_args.Req = Req
	var _result LikeVideoResult
	if err = p.c.Call(ctx, "LikeVideo", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UnLikeVideo(ctx context.Context, Req *videoproto.UnLikeVideoReq) (r *videoproto.UnLikeVideoResp, err error) {
	var _args UnLikeVideoArgs
	_args.Req = Req
	var _result UnLikeVideoResult
	if err = p.c.Call(ctx, "UnLikeVideo", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetLikeVideoList(ctx context.Context, Req *videoproto.GetLikeVideoListReq) (r *videoproto.GetLikeVideoListResp, err error) {
	var _args GetLikeVideoListArgs
	_args.Req = Req
	var _result GetLikeVideoListResult
	if err = p.c.Call(ctx, "GetLikeVideoList", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
